Name
====


JooseX.CPS - Implementation of the Continuation Passing Style<sup>[1](http://en.wikipedia.org/wiki/Continuation-passing_style)</sup> for JavaScript, plus some syntax sugar, simplifying its usage with Joose


SYNOPSIS
========

Procedural approach:

        UI.maskScreen("Please wait")
        
        TRY(function (url, data) {
                    
            XHR.request({
                url      : url,
                data     : 'data',
            
                callback : this.CONT.getCONTINUE(),
                errback  : this.CONT.getTHROW()
            })
            
        }).THEN(function (response) {
            
            if (response.isOk) {           
                alert('Saved correctly')
                
                this.CONT.CONTINUE()
            } else
                throw 'still got the error' // or: this.CONT.THROW('still got the error') 
            
        }).CATCH(function (e) {
        
            alert('Error during saving: ' + e)
            
            this.CONT.CONTINUE()
            
        }).FINALLY(function () {
        
            UI.removeScreenMask()
            
        }).NOW('http://remote.site.com/webservice', 'some data')
        
        
The same in OOP:        
        
        Class("DataStore", {
        
            trait : JooseX.CPS,
        
            has: {
                data    : { is: "rw" }
            },
            
            continued : {
            
                methods : {
                
                    save : function (url) {
                    
                        XHR.request({
                            url      : url,
                            data     : this.getData(),
                        
                            callback : this.getCONTINUE(),
                            errback  : this.getTHROW()
                        })
                    }
                }
            }
        })
        
        var store = new DataStore({
            data : [ 1, 2, 3 ]
        })
        
        UI.maskScreen("Please wait")
        
        store.save('http://remote.site.com/webservice').THEN(function (response) {
            
            if (response.isOk) {           
                alert('Saved correctly')
                
                this.CONTINUE()
            } else
                throw 'still got the error' // or: this.CONT.THROW('still got the error') 
            
        }).CATCH(function (e) {
        
            alert('Error during saving: ' + e)
            
            this.CONTINUE()
            
        }).FINALLY(function () {
        
            UI.removeScreenMask()
        }).NOW()


DESCRIPTION
===========

`JooseX.CPS` is a trait for meta-classes, which enables "Continuation passing style" in Joose methods and method modifiers.

`JooseX.CPS` allows you to define special "continued" methods and method modifiers, which forms the *asynchronous interface* of your class, 
and behave just like ordinary methods - can be inherited, composed from Role, etc.


STANDALONE USAGE
================

This module can be used on its own, completely separately from Joose. For this mode, use `TRY` function, which is exported to the global namespace.

### TRY

> `JooseX.CPS.Statement TRY(Function func, Object scope, Array args)`

> Create and setup an anonymous [JooseX.CPS.Statement]() instance. 

For the complete list of the available methods please refer to the link, in the meantime, take a look on the example below to see the main idea:

        TRY(function () {
        
            var CONT = this.CONT
            
            XHR.request({
                url      : url,
                data     : this.data,
            
                callback : this.CONT.getCONTINUE(),
                
                errback  : function (err1, err2) {
                    CONT.THROW(err1, err2) 
                }
            })
            
        }).CATCH(function (e1, e2) {
        
            ...
            
            this.CONT.CONTINUE()
        
        }).FINALLY(function () {
            
            ...
            
            this.CONT.CONTINUE()
                
        }).THEN(function(res1, res2) {
            ...
        }).THEN(
            ...
        ) 

As you can see, the control flow of the functions, wrapped with `TRY/CATCH/FINALLY` isn't managed by the standard `return` statement or explicit function end. 
Instead, to transfer the flow, you need to explicitly call the method on the embedded continuation instance, which is available as `this.CONT` (`this` scope can be passed as 2nd argument to TRY).

The call to such "control flow method" don't have to be synchronous - you can defer it arbitrary. This naturally allows to use them as callbacks (or errbacks).

However, the embedded continuation instance is only valid on the "synchronous interval" of the function execution. If you are deferring the call to the control flow method, 
either capture the continuation to the closure, or use one of the `getCONTINUE/getTHROW/getRETURN` methods (see the example above).

The arguments to the control flow method will become arguments to the next corresponding section of the flow:

        // CONTINUE transfers to next THEN section
        
        var tryScope = {}

        TRY(function (p1) {
            // p1 == 'p1'
            // this == tryScope 
        
            this.CONT.CONTINUE('value1', 'value2')

        }, tryScope).THEN(function(arg1, arg2) {
            // arg1 == 'value1', arg2 == 'value2' 
            
            this.CONT.CONTINUE('value3', 'value4')
            
        }).THEN(function(arg1, arg2) {
            // arg1 == 'value3', arg2 == 'value4' 
            
        }).NOW('p1') 

        
        

        // THROW transfers to the corresponding CATCH section
        
        var catchScope = {}

        TRY(function (p1) {
            // p1 == 'p1'
        
            this.CONT.THROW('error1', 'error2')

        }).CATCH(function(arg1, arg2) {
            // arg1 == 'error1', arg2 == 'error2'
            // this == catchScope 
            
            this.CONT.CONTINUE('value3', 'value4')
            
        }, catchScope).FINALLY(function() {
        
            this.CONTINUE()
            
        }).THEN(function(arg1, arg2) {
            // arg1 == 'value3', arg2 == 'value4' 
            
        }).NOW('p1') 


Features
--------

- You can't return the value from the statement's function, using the standard `return`. Any value returned will throw an exception. 

- The `CATCH/FINALLY` statements are also "continued" - they have embedded continuation instance, and **do not** transfer the control flow without call to `CONTINUE` (or other method).
If you'll forget to call it - your control flow will remain inside of the `CATCH/FINALLY` statement

- Arguments to `CONTINUE` from inside the `CATCH` statement will be passed further on flow - to the next `THEN` section (***this may change in future versions***)

- Arguments to `CONTINUE` from inside the `FINALLY` statement will be ignored.

- You can pass the scope for the statement's function as the 2nd argument of any control flow method

- You can pass the arguments for the statement's function as the 3rd argument of any control flow method. This will *override* the arguments received from the previous statement (or from `NOW`, see below).


Activation
----------

The control flow, defined with the `TRY/CATCH/FINALLY` will not start immediately. To start it, call the `NOW` method of the continuation. 

Arguments to `NOW` will become the arguments to the initial statement (see the example above).     


Nesting
-------

You can nest the statements arbitrary. To do it, instead of global `TRY` use the `TRY` method of the embedded continuation:

        TRY(function () {
        
            this.CONT.TRY(function () {
                XHR.request({
                    url      : url,
                    data     : this.data,
                
                    callback : this.CONT.getCONTINUE(),
                    errback  : function (err1, err2) {
                        CONT.THROW(err1, err2) 
                    }
                })
            }).THEN(function () {
            
                // do something else
            
            }).NOW()
            
            
        }).CATCH(function (e1, e2) {
        
            ...
            
            this.CONT.CONTINUE()
        
        }).FINALLY(function () {
            
            ...
            
            this.CONT.CONTINUE()
                
        }).THEN(function(res1, res2) {
            ...
        }).THEN(
            ...
        ) 
    
    
Exceptions
----------

To raise the exceptions you have 2 options. If you are raising it, during the "synchronous interval" of the statement's function, you can just use the standard `throw`:

        TRY(function (arg1, arg2) {
        
            if (!arg1 || !arg2) throw new MyException({ description : 'Incorrect arguments' })
            
            ...
        
        }).CATCH(function (e) {
        
            this.CONT.CONTINUE()
        
        }).FINALLY(function () {
            ...
        }).NOW()


If you are raising it deferred, use the `THROW` method of the continuation:

        TRY(function (arg1, arg2) {
        
            var CONT = this.CONT
            
            XHR.request({
                errback  : function (err1, err2) {
                    
                    CONT.THROW(new MyException({ param1 : err1, param2 : err2 })) 
                }
            })
        
        }).CATCH(function (e) {
        
            this.CONT.CONTINUE()
        
        }).FINALLY(function () {
            ...
        }).NOW()

Note, that with `THROW` you can throw (and accordingly catch) several values.

Exceptions from the nested statements will be correctly caught/handled by the outer `CATCH` statements. All `FINALLY` statements will be honored, in the correct order.

You can re-throw the exceptions from `CATCH/FINALLY` statements, to propagate it.


Statement boundaries
--------------------

When defining your control flow with `TRY/THEN/CATCH/FINALLY`, consider the following rules, which affect the scope of `CATCH/FINALLY` statements.

- `THEN` is just a synonym for `TRY`. Calls to `TRY/THEN` add statements to the sequential group.

- `CATCH/FINALLY` will handle the exceptions from the immediate previous sequential group

- `THEN` after `CATCH/FINALLY` will start a new sequential group 

If you need to explicitly start a new sequential group use `NEXT`. Take a look on some illustrating examples:


        TRY(function () {                         |     try {
                                                  |         doSomething1()
            doSomething1()                        |         doSomething2()
                                                  |     } catch (e) {
        }).THEN(function() {                      |
                                                  |         doCatch()
            doSomething2()                        |              
                                                  |     } finally {
        }).CATCH(function() {                     |         doFinally()
                                                  |     }
            doCatch()                             |
                                                  |
        }).FINALLY(function () {                  |
                                                  |
            doFinally()                           |
        })                                        |
        



















        TRY(function () {                         |     doSomething1()
                                                  |    
            doSomething1()                        |     try {
                                                  |         doSomething2()
        }).NEXT(function() {                      |         
                                                  |     } catch (e) {
            doSomething2()                        |         doCatch()
                                                  |     } 
        }).CATCH(function() {                     |    
                                                  |     try {
            doCatch()                             |         
                                                  |         doSomething3()
        }).THEN(function (){                      |         
                                                  |     } finally {
            doSomething3()                        |         doFinally()
                                                  |     }
        }).FINALLY(function () {                  |
                                                  |
            doFinally()                           |
        })                                        |



Return
------


Parallel statements
-------------------

`AND`


<br><br>


USAGE IN JOOSE CLASSES
======================

`continued` BUILDER
-------------------

Adding `JooseX.CPS` trait will provide your class with the `continued` builder. This builder groups the declaration of the "asynchronous part" of your class.
Inside it, you can use the following builders: `methods`, `override`, `after`, `before`. This builders have the same meaning as standard ones, however instead of usual, 
they defines the "continued" methods.


"Continued" methods
-------------------

These methods are called "continued", because they are implicitly wrapped with the "continued" `TRY` statement, described in the section above.
Inside of such methods is also embedded the continuation instance, available as `this.CONT` 


        Class("DataStore", {
            trait : JooseX.CPS,
        
            continued : {
            
                methods : {
                
                    save : function (url) {
                        if (!url.test(/^http/) throw "Invalid URL"
                        
                        ...
                        
                        this.CONT.CONTINUE(result)
                    }
                }
            }
        })
        

Continued methods have the same [features][] as functions, wrapped with `TRY`, plus a very important additional one, see below.


Implicit methods chaining
-------------------------





"Continued" method modifiers
----------------------------



Overriding usual methods
------------------------





EXAMPLES
========


GETTING HELP
============

This extension is supported via github issues tracker: <http://github.com/SamuraiJack/JooseX-CPS/issues>

For general Joose questions you can also visit the [#joose](http://webchat.freenode.net/?randomnick=1&channels=joose&prompt=1) on irc.freenode.org, or the forum at <http://joose.it/forum>


SEE ALSO
========

[Continuation Passing Style](http://en.wikipedia.org/wiki/Continuation-passing_style)

Web page of this extension: <http://github.com/SamuraiJack/JooseX-CPS/>

General information about Joose: <http://joose.it>


BUGS
====

All complex software has bugs lurking in it, and this module is no exception.

Please report any bugs through the web interface at <http://github.com/SamuraiJack/JooseX-CPS/issues>



AUTHORS
=======

Nickolay Platonov <nplatonov@cpan.org>



COPYRIGHT AND LICENSE
=====================

Copyright (c) 2009, Nickolay Platonov

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

[JooseX.CPS.Statement]: CPS/Statement.html
[JooseX.CPS.ControlFlow]: CPS/ControlFlow.html
